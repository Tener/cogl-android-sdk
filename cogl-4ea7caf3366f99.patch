diff --git a/cogl/cogl-context.c b/cogl/cogl-context.c
index 21c10b7..2505bf7 100644
--- a/cogl/cogl-context.c
+++ b/cogl/cogl-context.c
@@ -511,6 +511,7 @@ _cogl_context_free (CoglContext *context)
 
   g_byte_array_free (context->buffer_map_fallback_array, TRUE);
 
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX display ref count=%d\n", ((CoglObject *)context->display)->ref_count);
   cogl_object_unref (context->display);
 
   g_free (context);
diff --git a/cogl/driver/gles/cogl-gles.c b/cogl/driver/gles/cogl-gles.c
index df90c57..3ca4013 100644
--- a/cogl/driver/gles/cogl-gles.c
+++ b/cogl/driver/gles/cogl-gles.c
@@ -41,6 +41,8 @@ _cogl_gles_update_features (CoglContext *context,
   CoglFeatureFlags flags = 0;
   const char *gl_extensions;
   int num_stencil_bits = 0;
+  void *get_string;
+  const char *gl_extensions_2;
 
   /* We have to special case getting the pointer to the glGetString
      function because we need to use it to determine what functions we
@@ -49,16 +51,13 @@ _cogl_gles_update_features (CoglContext *context,
     (void *) _cogl_renderer_get_proc_address (context->display->renderer,
                                               "glGetString");
 
-  COGL_NOTE (WINSYS,
-             "Checking features\n"
-             "  GL_VENDOR: %s\n"
-             "  GL_RENDERER: %s\n"
-             "  GL_VERSION: %s\n"
-             "  GL_EXTENSIONS: %s",
-             context->glGetString (GL_VENDOR),
-             context->glGetString (GL_RENDERER),
-             context->glGetString (GL_VERSION),
-             context->glGetString (GL_EXTENSIONS));
+  get_string = glGetString;
+  gl_extensions_2 = glGetString (GL_VENDOR);
+
+  g_warning (" GL_VENDOR: %s", context->glGetString (GL_VENDOR));
+  g_warning (" GL_RENDERER: %s", context->glGetString (GL_RENDERER));
+  g_warning (" GL_VERSION: %s", context->glGetString (GL_VERSION));
+  g_warning (" GL_EXTENSIONS: %s", context->glGetString (GL_EXTENSIONS));
 
   gl_extensions = (const char*) context->glGetString (GL_EXTENSIONS);
 
diff --git a/cogl/winsys/cogl-winsys-egl-android.c b/cogl/winsys/cogl-winsys-egl-android.c
index 2efa6b2..0c22deb 100644
--- a/cogl/winsys/cogl-winsys-egl-android.c
+++ b/cogl/winsys/cogl-winsys-egl-android.c
@@ -29,6 +29,7 @@
 #include "config.h"
 #endif
 
+#include <stdint.h>
 #include <android/native_window.h>
 
 #include "cogl-winsys-egl-android-private.h"
@@ -62,6 +63,7 @@ _cogl_winsys_renderer_disconnect (CoglRenderer *renderer)
 {
   CoglRendererEGL *egl_renderer = renderer->winsys;
 
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX eglTerminate\n");
   eglTerminate (egl_renderer->edpy);
 
   g_slice_free (CoglRendererEGL, egl_renderer);
@@ -78,6 +80,7 @@ _cogl_winsys_renderer_connect (CoglRenderer *renderer,
 
   egl_renderer->platform_vtable = &_cogl_winsys_egl_vtable;
 
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXX eglGetDisplay()");
   egl_renderer->edpy = eglGetDisplay (EGL_DEFAULT_DISPLAY);
 
   if (!_cogl_winsys_egl_renderer_connect_common (renderer, error))
@@ -116,6 +119,11 @@ _cogl_winsys_egl_context_created (CoglDisplay *display,
                       egl_display->egl_config,
                       EGL_NATIVE_VISUAL_ID, &format);
 
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX config=%d, format=%d, android_native_window = %p\n",
+             egl_display->egl_config,
+             format,
+             android_native_window);
+
   ANativeWindow_setBuffersGeometry (android_native_window,
                                     0,
                                     0,
@@ -131,6 +139,8 @@ _cogl_winsys_egl_context_created (CoglDisplay *display,
       error_message = "Unable to create EGL window surface";
       goto fail;
     }
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX eglCreateWindowSurface(%p) = %p\n",
+             egl_renderer->edpy, egl_display->egl_surface);
 
   if (!eglMakeCurrent (egl_renderer->edpy,
                        egl_display->egl_surface,
@@ -154,6 +164,7 @@ _cogl_winsys_egl_context_created (CoglDisplay *display,
   return TRUE;
 
  fail:
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX %s\n", error_message);
   g_set_error (error, COGL_WINSYS_ERROR,
                COGL_WINSYS_ERROR_CREATE_CONTEXT,
                "%s", error_message);
@@ -181,6 +192,22 @@ _cogl_winsys_egl_display_destroy (CoglDisplay *display)
   g_slice_free (CoglDisplayAndroid, egl_display->platform);
 }
 
+static void
+_cogl_winsys_egl_cleanup_context (CoglDisplay *display)
+{
+  CoglRenderer *renderer = display->renderer;
+  CoglRendererEGL *egl_renderer = renderer->winsys;
+  CoglDisplayEGL *egl_display = display->winsys;
+
+  if (egl_display->egl_surface != EGL_NO_SURFACE)
+    {
+      g_warning ("--------------------------- eglDestroySurface(%p, %p)",
+                 egl_renderer->edpy, egl_display->egl_surface);
+      eglDestroySurface (egl_renderer->edpy, egl_display->egl_surface);
+      egl_display->egl_surface = EGL_NO_SURFACE;
+    }
+}
+
 static gboolean
 _cogl_winsys_egl_onscreen_init (CoglOnscreen *onscreen,
                                 EGLConfig egl_config,
@@ -217,6 +244,7 @@ _cogl_winsys_egl_vtable =
   {
     .display_setup = _cogl_winsys_egl_display_setup,
     .display_destroy = _cogl_winsys_egl_display_destroy,
+    .cleanup_context = _cogl_winsys_egl_cleanup_context,
     .context_created = _cogl_winsys_egl_context_created,
     .onscreen_init = _cogl_winsys_egl_onscreen_init,
   };
diff --git a/cogl/winsys/cogl-winsys-egl-private.h b/cogl/winsys/cogl-winsys-egl-private.h
index 6658278..9714e38 100644
--- a/cogl/winsys/cogl-winsys-egl-private.h
+++ b/cogl/winsys/cogl-winsys-egl-private.h
@@ -88,6 +88,8 @@ typedef struct _CoglRendererEGL
   EGLint egl_version_major;
   EGLint egl_version_minor;
 
+  GHashTable *core_functions_hash;
+
   /* Data specific to the EGL platform */
   void *platform;
   /* vtable for platform specific parts */
diff --git a/cogl/winsys/cogl-winsys-egl.c b/cogl/winsys/cogl-winsys-egl.c
index ce5d5da..27ac3b0 100644
--- a/cogl/winsys/cogl-winsys-egl.c
+++ b/cogl/winsys/cogl-winsys-egl.c
@@ -84,12 +84,77 @@ static const CoglFeatureData winsys_feature_data[] =
 #include "cogl-winsys-egl-feature-functions.h"
   };
 
+/* Define an array of features */
+#undef COGL_EXT_BEGIN
+#define COGL_EXT_BEGIN(name,                                            \
+                       min_gl_major, min_gl_minor,                      \
+                       gles_availability,                               \
+                       namespaces, extension_names)
+#undef COGL_EXT_FUNCTION
+#define COGL_EXT_FUNCTION(ret, name, args)  #name,
+#undef COGL_EXT_END
+#define COGL_EXT_END()
+
+static GHashTable *
+create_core_functions_table (CoglRenderer *renderer, const char **functions)
+{
+  GHashTable *table;
+  int i;
+
+  table = g_hash_table_new (g_str_hash, g_str_equal);
+  for (i = 0; functions[i]; i++)
+    {
+      void *ptr;
+      g_module_symbol (renderer->libgl_module, functions[i], &ptr);
+      if (G_UNLIKELY (!ptr))
+        {
+          g_warning ("Core driver symbol missing: %s", functions[i]);
+          continue;
+        }
+      g_hash_table_insert (table, (void *)functions[i], ptr);
+    }
+  return table;
+}
+
 static CoglFuncPtr
 _cogl_winsys_renderer_get_proc_address (CoglRenderer *renderer,
                                         const char *name)
 {
+  CoglRendererEGL *egl_renderer = renderer->winsys;
   void *ptr;
 
+  if (renderer->driver == COGL_DRIVER_GLES1 ||
+      renderer->driver == COGL_DRIVER_GLES2)
+    {
+      const char *gles1_functions[] = {
+#include "gl-prototypes/cogl-gles1-functions.h"
+        NULL
+      };
+      const char *gles2_functions[] = {
+#include "gl-prototypes/cogl-gles2-functions.h"
+        NULL
+      };
+      const char **functions;
+
+      if (!egl_renderer->core_functions_hash)
+        {
+          if (renderer->driver == COGL_DRIVER_GLES1)
+            functions = gles1_functions;
+          else if (renderer->driver == COGL_DRIVER_GLES2)
+            functions = gles2_functions;
+
+          egl_renderer->core_functions_hash =
+            create_core_functions_table (renderer, functions);
+        }
+
+      ptr = g_hash_table_lookup (egl_renderer->core_functions_hash, name);
+      if (ptr)
+        return ptr;
+
+      /* FIXME: for GL we currently just assume that the
+       * driver will return NULL for core symbols. */
+    }
+
   ptr = eglGetProcAddress (name);
 
   /* eglGetProcAddress doesn't support fetching core API so we need to
@@ -138,6 +203,7 @@ _cogl_winsys_egl_renderer_connect_common (CoglRenderer *renderer,
 {
   CoglRendererEGL *egl_renderer = renderer->winsys;
 
+  g_warning ("XXXXXXXXXXXXXXXXXXXXXX eglInitialize()");
   if (!eglInitialize (egl_renderer->edpy,
                       &egl_renderer->egl_version_major,
                       &egl_renderer->egl_version_minor))
@@ -177,8 +243,10 @@ egl_attributes_from_framebuffer_config (CoglDisplay *display,
                                                               config,
                                                               attributes);
 
+#if 1
   attributes[i++] = EGL_STENCIL_SIZE;
   attributes[i++] = needs_stencil_override ? 2 : 0;
+#endif
 
   attributes[i++] = EGL_RED_SIZE;
   attributes[i++] = 1;
@@ -187,25 +255,32 @@ egl_attributes_from_framebuffer_config (CoglDisplay *display,
   attributes[i++] = EGL_BLUE_SIZE;
   attributes[i++] = 1;
 
+#if 1
   attributes[i++] = EGL_ALPHA_SIZE;
   attributes[i++] = config->swap_chain->has_alpha ? 1 : EGL_DONT_CARE;
+#endif
 
+#if 1
   attributes[i++] = EGL_DEPTH_SIZE;
   attributes[i++] = 1;
 
   attributes[i++] = EGL_BUFFER_SIZE;
   attributes[i++] = EGL_DONT_CARE;
+#endif
 
+#if 1
   attributes[i++] = EGL_RENDERABLE_TYPE;
   attributes[i++] = (renderer->driver == COGL_DRIVER_GL ?
                       EGL_OPENGL_BIT :
                       renderer->driver == COGL_DRIVER_GLES1 ?
                       EGL_OPENGL_ES_BIT :
                       EGL_OPENGL_ES2_BIT);
+#endif
 
   attributes[i++] = EGL_SURFACE_TYPE;
   attributes[i++] = EGL_WINDOW_BIT;
 
+#if 1
   if (config->samples_per_pixel)
     {
        attributes[i++] = EGL_SAMPLE_BUFFERS;
@@ -213,6 +288,7 @@ egl_attributes_from_framebuffer_config (CoglDisplay *display,
        attributes[i++] = EGL_SAMPLES;
        attributes[i++] = config->samples_per_pixel;
     }
+#endif
 
   attributes[i++] = EGL_NONE;
 
@@ -518,9 +594,11 @@ _cogl_winsys_onscreen_deinit (CoglOnscreen *onscreen)
     return;
   if (egl_onscreen->egl_surface != EGL_NO_SURFACE)
     {
+#if 0
       if (eglDestroySurface (egl_renderer->edpy, egl_onscreen->egl_surface)
           == EGL_FALSE)
         g_warning ("Failed to destroy EGL surface");
+#endif
       egl_onscreen->egl_surface = EGL_NO_SURFACE;
     }
 
diff --git a/examples/android/hello/AndroidManifest.xml b/examples/android/hello/AndroidManifest.xml
index 3cb6026..8354579 100644
--- a/examples/android/hello/AndroidManifest.xml
+++ b/examples/android/hello/AndroidManifest.xml
@@ -1,7 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- BEGIN_INCLUDE(manifest) -->
+<!-- XXX: the package name had to be hacked to get a favourable
+     package listing in /data/system/packages.list in the first
+     8k to workaround a bug in the run-as command. -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="org.cogl.Hello"
+        package="com.cogl.example.zzz.Hello"
         android:versionCode="1"
         android:versionName="1.0">
 
@@ -9,7 +12,7 @@
     <uses-sdk android:minSdkVersion="9" />
 
     <!-- This .apk has no Java code itself, so set hasCode to false. -->
-    <application android:label="@string/app_name" android:hasCode="false">
+    <application android:label="@string/app_name" android:hasCode="false" android:debuggable="true">
 
         <!-- Our activity is the built-in NativeActivity framework class.
              This will take care of integrating with our NDK code. -->
diff --git a/examples/android/hello/build.xml b/examples/android/hello/build.xml
index d69afbc..19afd0b 100644
--- a/examples/android/hello/build.xml
+++ b/examples/android/hello/build.xml
@@ -1,15 +1,14 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project name="TestCoglHello" default="help">
 
-<!-- The local.properties file is created and updated by the 'android'
-     tool.
-     It contains the path to the SDK. It should *NOT* be checked into
-     Version Control Systems. -->
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
     <property file="local.properties" />
 
-    <!-- The build.properties file can be created by you and is never touched
-         by the 'android' tool. This is the place to change some of the
-         default property values used by the Ant rules.
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
          Here are some properties you may want to change/update:
 
          source.dir
@@ -17,6 +16,9 @@
          out.dir
              The name of the output directory. Default is 'bin'.
 
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
          Properties related to the SDK location or the project target should
          be updated using the 'android' tool with the 'update' action.
 
@@ -24,26 +26,25 @@
          application and should be checked into Version Control Systems.
 
          -->
-    <property file="build.properties" />
+    <property file="ant.properties" />
 
-    <!-- The default.properties file is created and updated by the 'android'
+    <!-- The project.properties file is created and updated by the 'android'
          tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
          This file is an integral part of the build system for your
          application and should be checked into Version Control Systems. -->
-    <property file="default.properties" />
+    <loadproperties srcFile="project.properties" />
 
-    <!-- Custom Android task to deal with the project target, and import the
-         proper rules.
-         This requires ant 1.6.0 or above. -->
-    <path id="android.antlibs">
-        <pathelement path="${sdk.dir}/tools/lib/anttasks.jar" />
-        <pathelement path="${sdk.dir}/tools/lib/sdklib.jar" />
-        <pathelement path="${sdk.dir}/tools/lib/androidprefs.jar" />
-    </path>
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
 
-    <taskdef name="setup"
-        classname="com.android.ant.SetupTask"
-        classpathref="android.antlibs" />
 
 <!-- extension targets. Uncomment the ones where you want to do custom work
      in between standard targets -->
@@ -53,32 +54,32 @@
     <target name="-pre-compile">
     </target>
 
-    [This is typically used for code obfuscation.
-     Compiled code location: ${out.classes.absolute.dir}
-     If this is not done in place, override ${out.dex.input.absolute.dir}]
+    /* This is typically used for code obfuscation.
+       Compiled code location: ${out.classes.absolute.dir}
+       If this is not done in place, override ${out.dex.input.absolute.dir} */
     <target name="-post-compile">
     </target>
 -->
 
-
-    <!-- Execute the Android Setup task that will setup some properties
-         specific to the target, and import the build rules files.
-
-         The rules file is imported from
-            <SDK>/platforms/<target_platform>/ant/ant_rules_r#.xml
+    <!-- Import the actual build file.
 
          To customize existing targets, there are two options:
          - Customize only one target:
              - copy/paste the target into this file, *before* the
-               <setup> task.
+               <import> task.
              - customize it to your needs.
-         - Customize the whole script.
+         - Customize the whole content of build.xml
              - copy/paste the content of the rules files (minus the top node)
-               into this file, *after* the <setup> task
-             - disable the import of the rules by changing the setup task
-               below to <setup import="false" />.
+               into this file, replacing the <import> task.
              - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
     -->
-    <setup />
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
 
 </project>
diff --git a/examples/android/hello/jni/Android.mk b/examples/android/hello/jni/Android.mk
index 01c811c..cbb0735 100644
--- a/examples/android/hello/jni/Android.mk
+++ b/examples/android/hello/jni/Android.mk
@@ -5,15 +5,19 @@ include $(CLEAR_VARS)
 LOCAL_MODULE    := test-cogl-hello
 LOCAL_SRC_FILES := main.c
 LOCAL_LDLIBS    := -llog -landroid -lEGL -lGLESv1_CM
-LOCAL_STATIC_LIBRARIES := cogl android_native_app_glue gobject gmodule gthread glib-android glib iconv
+LOCAL_STATIC_LIBRARIES := cogl android_native_app_glue glib-android gobject gmodule gthread glib iconv intl
 LOCAL_ARM_MODE := arm
 LOCAL_CFLAGS := 				\
 	-DG_LOG_DOMAIN=\"TestCoglHello\"	\
 	-DCOGL_ENABLE_EXPERIMENTAL_2_0_API	\
+	-g3 -O0					\
 	$(NULL)
 
 include $(BUILD_SHARED_LIBRARY)
 
 $(call import-module,android/native_app_glue)
+$(call import-module,gettext)
+$(call import-module,libiconv)
 $(call import-module,glib)
+$(call import-module,glib-android)
 $(call import-module,cogl)
diff --git a/examples/android/hello/jni/main.c b/examples/android/hello/jni/main.c
index dacbbab..066fe5d 100644
--- a/examples/android/hello/jni/main.c
+++ b/examples/android/hello/jni/main.c
@@ -84,6 +84,7 @@ static test_draw_frame_and_swap (TestData *data)
 {
   if (data->context)
     {
+      cogl_framebuffer_clear4f (data->fb, COGL_BUFFER_BIT_COLOR, 1, 0, 0, 1);
       cogl_primitive_draw (data->triangle);
       cogl_framebuffer_swap_buffers (data->fb);
     }
@@ -152,12 +153,22 @@ void
 android_main (struct android_app* application)
 {
   TestData data;
+  int debug = 1;
 
   /* Make sure glue isn't stripped */
   app_dummy ();
 
   g_android_init ();
 
+#if 0
+  g_warning ("YYYYXXXXXXXXXXXXXXXXXXXXXXXXXX");
+
+  while (debug)
+    ;
+
+  g_warning ("YYYYXXXXXXXXXXXXXXXXXXXXXXXXXX");
+#endif
+
   memset (&data, 0, sizeof (TestData));
   application->userData = &data;
   application->onAppCmd = test_handle_cmd;
