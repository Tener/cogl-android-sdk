From 3793c21f5aa716813a73d45320cffa806693d57e Mon Sep 17 00:00:00 2001
From: Damien Lespiau <damien.lespiau@intel.com>
Date: Wed, 23 May 2012 18:19:29 +0100
Subject: [PATCH 2/2] Support retrieving depth textures from framebuffers

This commit introduces two new funtions on framebuffers to be able to
retrieve the depth buffer as a texture for further usage, say, to
implement shadow mapping.

The proposed API works as follow:
  * Before the framebuffer is allocated, you can request that a depth
    texture is created with cogl_framebuffer_enable_depth_texture()
  * cogl_framebuffer_get_depth_texture() can then be used to grab a
    CoglTexture
---
 cogl/cogl-bitmap-conversion.c   |   5 ++
 cogl/cogl-bitmap-packing.h      |  10 ++++
 cogl/cogl-context.h             |   4 +-
 cogl/cogl-framebuffer-private.h |   2 +
 cogl/cogl-framebuffer.c         | 117 +++++++++++++++++++++++++++++++++++++---
 cogl/cogl-framebuffer.h         |  42 +++++++++++++++
 cogl/cogl-types.h               |  28 +++++++---
 cogl/driver/gl/cogl-gl.c        |  34 ++++++++++++
 cogl/driver/gles/cogl-gles.c    |  42 +++++++++++++++
 examples/cogl-info.c            |   6 +++
 10 files changed, 276 insertions(+), 14 deletions(-)

diff --git a/cogl/cogl-bitmap-conversion.c b/cogl/cogl-bitmap-conversion.c
index 17b26e6..9d06bd7 100644
--- a/cogl/cogl-bitmap-conversion.c
+++ b/cogl/cogl-bitmap-conversion.c
@@ -306,6 +306,11 @@ _cogl_bitmap_needs_short_temp_buffer (CoglPixelFormat format)
      floats */
   switch (format)
     {
+    case COGL_PIXEL_FORMAT_DEPTH_ANY:
+    case COGL_PIXEL_FORMAT_DEPTH_16:
+    case COGL_PIXEL_FORMAT_DEPTH_24:
+    case COGL_PIXEL_FORMAT_DEPTH_32:
+    case COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8:
     case COGL_PIXEL_FORMAT_ANY:
     case COGL_PIXEL_FORMAT_YUV:
       g_assert_not_reached ();
diff --git a/cogl/cogl-bitmap-packing.h b/cogl/cogl-bitmap-packing.h
index f84af02..aa79f05 100644
--- a/cogl/cogl-bitmap-packing.h
+++ b/cogl/cogl-bitmap-packing.h
@@ -370,6 +370,11 @@ G_PASTE (_cogl_unpack_, component_type) (CoglPixelFormat format,
     case COGL_PIXEL_FORMAT_ABGR_2101010_PRE:
       G_PASTE (_cogl_unpack_abgr_2101010_, component_type) (src, dst, width);
       break;
+    case COGL_PIXEL_FORMAT_DEPTH_ANY:
+    case COGL_PIXEL_FORMAT_DEPTH_16:
+    case COGL_PIXEL_FORMAT_DEPTH_24:
+    case COGL_PIXEL_FORMAT_DEPTH_32:
+    case COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8:
     case COGL_PIXEL_FORMAT_ANY:
     case COGL_PIXEL_FORMAT_YUV:
       g_assert_not_reached ();
@@ -711,6 +716,11 @@ G_PASTE (_cogl_pack_, component_type) (CoglPixelFormat format,
     case COGL_PIXEL_FORMAT_ABGR_2101010_PRE:
       G_PASTE (_cogl_pack_abgr_2101010_, component_type) (src, dst, width);
       break;
+    case COGL_PIXEL_FORMAT_DEPTH_ANY:
+    case COGL_PIXEL_FORMAT_DEPTH_16:
+    case COGL_PIXEL_FORMAT_DEPTH_24:
+    case COGL_PIXEL_FORMAT_DEPTH_32:
+    case COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8:
     case COGL_PIXEL_FORMAT_ANY:
     case COGL_PIXEL_FORMAT_YUV:
       g_assert_not_reached ();
diff --git a/cogl/cogl-context.h b/cogl/cogl-context.h
index 616cd77..a091919 100644
--- a/cogl/cogl-context.h
+++ b/cogl/cogl-context.h
@@ -205,7 +205,8 @@ cogl_is_context (void *object);
  *     for swap buffer completions.
  * @COGL_FEATURE_ID_GLES2_CONTEXT: Whether creating new GLES2 contexts is
  *    suported.
- *
+ * @COGL_FEATURE_ID_DEPTH_TEXTURE: Whether #CoglFramebuffer support rendering
+ *     the depth buffer to a texture.
  *
  * All the capabilities that can vary between different GPUs supported
  * by Cogl. Applications that depend on any of these features should explicitly
@@ -234,6 +235,7 @@ typedef enum _CoglFeatureID
   COGL_FEATURE_ID_MIRRORED_REPEAT,
   COGL_FEATURE_ID_SWAP_BUFFERS_EVENT,
   COGL_FEATURE_ID_GLES2_CONTEXT,
+  COGL_FEATURE_ID_DEPTH_TEXTURE,
 
   /*< private > */
   _COGL_N_FEATURE_IDS
diff --git a/cogl/cogl-framebuffer-private.h b/cogl/cogl-framebuffer-private.h
index ccc9c22..3152049 100644
--- a/cogl/cogl-framebuffer-private.h
+++ b/cogl/cogl-framebuffer-private.h
@@ -51,6 +51,7 @@ typedef struct
 {
   CoglSwapChain *swap_chain;
   CoglBool need_stencil;
+  CoglBool need_depth_texture;
   int samples_per_pixel;
   CoglBool swap_throttled;
 } CoglFramebufferConfig;
@@ -176,6 +177,7 @@ typedef struct _CoglGLFramebuffer
 {
   GLuint fbo_handle;
   GList *renderbuffers;
+  CoglTexture *depth_texture;
   int samples_per_pixel;
 } CoglGLFramebuffer;
 
diff --git a/cogl/cogl-framebuffer.c b/cogl/cogl-framebuffer.c
index 13b3e24..006697c 100644
--- a/cogl/cogl-framebuffer.c
+++ b/cogl/cogl-framebuffer.c
@@ -820,6 +820,60 @@ _cogl_offscreen_free (CoglOffscreen *offscreen)
   g_free (offscreen);
 }
 
+static CoglTexture *
+try_creating_depth_texture (CoglContext *ctx,
+                            int width,
+                            int height,
+                            CoglOffscreenAllocateFlags flags)
+{
+  CoglTexture2D *depth_texture = NULL;
+  GLuint tex_gl_handle;
+  GLenum tex_gl_target;
+
+  if (flags & COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH24_STENCIL8)
+    {
+      /* attatch a newly created GL_DEPTH24_STENCIL8 texture to the
+       * GL_DEPTH_ATTACHMENT and GL_STENCIL_ATTACHMENT attachement points */
+      depth_texture =
+        cogl_texture_2d_new_with_size (ctx,
+                                       width, height,
+                                       COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8,
+                                       NULL);
+
+      cogl_texture_get_gl_texture (COGL_TEXTURE (depth_texture),
+                                   &tex_gl_handle, &tex_gl_target);
+
+      GE (ctx, glFramebufferTexture2D (GL_FRAMEBUFFER,
+                                       GL_DEPTH_ATTACHMENT,
+                                       tex_gl_target, tex_gl_handle,
+                                       0));
+      GE (ctx, glFramebufferTexture2D (GL_FRAMEBUFFER,
+                                       GL_STENCIL_ATTACHMENT,
+                                       tex_gl_target, tex_gl_handle,
+                                       0));
+    }
+  else if (flags & COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH)
+    {
+      /* attatch a newly created GL_DEPTH_COMPONENT16 texture to the
+       * GL_DEPTH_ATTACHMENT attachement point */
+      depth_texture =
+        cogl_texture_2d_new_with_size (ctx,
+                                       width, height,
+                                       COGL_PIXEL_FORMAT_DEPTH_16,
+                                       NULL);
+
+      cogl_texture_get_gl_texture (COGL_TEXTURE (depth_texture),
+                                   &tex_gl_handle, &tex_gl_target);
+
+      GE (ctx, glFramebufferTexture2D (GL_FRAMEBUFFER,
+                                       GL_DEPTH_ATTACHMENT,
+                                       tex_gl_target, tex_gl_handle,
+                                       0));
+    }
+
+  return COGL_TEXTURE (depth_texture);
+}
+
 static GList *
 try_creating_renderbuffers (CoglContext *ctx,
                             int width,
@@ -968,12 +1022,39 @@ try_creating_fbo (CoglContext *ctx,
                                      tex_gl_target, tex_gl_handle,
                                      texture_level));
 
-  gl_framebuffer->renderbuffers =
-    try_creating_renderbuffers (ctx,
-                                texture_level_width,
-                                texture_level_height,
-                                flags,
-                                n_samples);
+  /* create either a depth/stencil texture, a depth texture or render buffers
+   * depending on what we've been asked to provide */
+
+  if (config->need_depth_texture &&
+      flags & (COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH24_STENCIL8 |
+               COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH))
+    {
+      gl_framebuffer->depth_texture =
+        try_creating_depth_texture (ctx,
+                                    texture_level_width,
+                                    texture_level_height,
+                                    flags);
+
+      if (gl_framebuffer->depth_texture)
+        {
+          /* The depth texture has been successfully created, let's clear
+           * the flags that are now fulfilled as we might need to create
+           * renderbuffers (for the ALLOCATE_FLAG_DEPTH | ALLOCATE_FLAG_STENCIL
+           * case */
+          flags &= ~(COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH24_STENCIL8 |
+                     COGL_OFFSCREEN_ALLOCATE_FLAG_DEPTH);
+        }
+    }
+
+  if (flags)
+    {
+      gl_framebuffer->renderbuffers =
+        try_creating_renderbuffers (ctx,
+                                    texture_level_width,
+                                    texture_level_height,
+                                    flags,
+                                    n_samples);
+    }
 
   /* Make sure it's complete */
   status = ctx->glCheckFramebufferStatus (GL_FRAMEBUFFER);
@@ -1126,6 +1207,10 @@ _cogl_offscreen_allocate (CoglOffscreen *offscreen,
                         flags = 0,
                         gl_framebuffer))
     {
+
+      if (gl_framebuffer->depth_texture)
+        _cogl_texture_associate_framebuffer (gl_framebuffer->depth_texture, fb);
+
       fb->samples_per_pixel = gl_framebuffer->samples_per_pixel;
 
       /* Record that the last set of flags succeeded so that we can
@@ -1901,6 +1986,26 @@ cogl_framebuffer_get_color_format (CoglFramebuffer *framebuffer)
   return framebuffer->format;
 }
 
+void
+cogl_framebuffer_enable_depth_texture (CoglFramebuffer *framebuffer,
+                                       gboolean         enabled)
+{
+  _COGL_RETURN_IF_FAIL (!framebuffer->allocated);
+
+  framebuffer->config.need_depth_texture = enabled;
+}
+
+CoglTexture *
+cogl_framebuffer_get_depth_texture (CoglFramebuffer *framebuffer)
+{
+  _COGL_RETURN_VAL_IF_FAIL (cogl_is_offscreen (framebuffer), NULL);
+
+  if (!cogl_framebuffer_allocate (framebuffer, NULL))
+    return NULL;
+
+  return COGL_OFFSCREEN(framebuffer)->gl_framebuffer.depth_texture;
+}
+
 int
 cogl_framebuffer_get_samples_per_pixel (CoglFramebuffer *framebuffer)
 {
diff --git a/cogl/cogl-framebuffer.h b/cogl/cogl-framebuffer.h
index f00e996..1c07f72 100644
--- a/cogl/cogl-framebuffer.h
+++ b/cogl/cogl-framebuffer.h
@@ -38,6 +38,7 @@
 #include <cogl/cogl-pipeline.h>
 #include <cogl/cogl-indices.h>
 #include <cogl/cogl-bitmap.h>
+#include <cogl/cogl-texture.h>
 #ifdef COGL_ENABLE_EXPERIMENTAL_API
 #include <cogl/cogl-quaternion.h>
 #include <cogl/cogl-euler.h>
@@ -807,6 +808,47 @@ CoglPixelFormat
 cogl_framebuffer_get_color_format (CoglFramebuffer *framebuffer);
 
 /**
+ * cogl_framebuffer_enable_depth_texture:
+ * @framebuffer: A #CoglFramebuffer
+ * @enabled: TRUE or FALSE
+ *
+ * If @enabled is #TRUE, the depth buffer used when rendering to @framebuffer
+ * is available as a texture. You can retrieve the texture with
+ * cogl_framebuffer_get_depth_texture().
+ *
+ * <note>It's possible that your GPU does not support depth textures. You
+ * should check the COGL_FEATURE_ID_DEPTH_TEXTURE feature before using this
+ * function.</note>
+ * <note>It's not valid to call this function after the framebuffer has been
+ * allocated as the creation of the depth texture is done at allocation time.
+ * </note>
+ *
+ * Since: 2.0
+ */
+void
+cogl_framebuffer_enable_depth_texture (CoglFramebuffer *framebuffer,
+                                       gboolean         enabled);
+
+/**
+ * cogl_framebuffer_get_depth_texture:
+ * @framebuffer: A #CoglFramebuffer
+ *
+ * Retrieves the depth buffer of @framebuffer as a #CoglTexture. You need to
+ * call cogl_framebuffer_get_depth_texture(fb, TRUE); before using this
+ * function.
+ *
+ * <note>Calling this function implicitely allocates the framebuffer.</note>
+ * <note>The texture returned stays valid as long as the framebuffer stays
+ * valid.</note>
+ *
+ * Returns: (transfer none): the depth texture
+ *
+ * Since: 2.0
+ */
+CoglTexture *
+cogl_framebuffer_get_depth_texture (CoglFramebuffer *framebuffer);
+
+/**
  * cogl_framebuffer_set_samples_per_pixel:
  * @framebuffer: A #CoglFramebuffer framebuffer
  * @samples_per_pixel: The minimum number of samples per pixel
diff --git a/cogl/cogl-types.h b/cogl/cogl-types.h
index 5b9c0f8..c1454bf 100644
--- a/cogl/cogl-types.h
+++ b/cogl/cogl-types.h
@@ -154,18 +154,22 @@ typedef struct _CoglTextureVertex       CoglTextureVertex;
 #define COGL_BGR_BIT            (1 << 5)
 #define COGL_AFIRST_BIT         (1 << 6)
 #define COGL_PREMULT_BIT        (1 << 7)
+#define COGL_DEPTH_BIT          (1 << 8)
+#define COGL_STENCIL_BIT        (1 << 9)
 
 /* XXX: Notes to those adding new formats here...
  *
  * First this diagram outlines how we allocate the 32bits of a
  * CoglPixelFormat currently...
  *
- *                             4 bits for flags
- *                             |--|
+ *                            6 bits for flags
+ *                          |-----|
  *  enum        unused             4 bits for the bytes-per-pixel
  *                                 and component alignment info
- *  |------| |---------------|     |--|
- *  00000000 xxxxxxxx xxxxxxxx PFBA0000
+ *  |------| |-------------|       |--|
+ *  00000000 xxxxxxxx xxxxxxSD PFBA0000
+ *                          ^ stencil
+ *                           ^ depth
  *                             ^ premult
  *                              ^ alpha first
  *                               ^ bgr order
@@ -187,7 +191,7 @@ typedef struct _CoglTextureVertex       CoglTextureVertex;
  * 4-6   = 2 bpp, not aligned (e.g. 565, 4444, 5551)
  * 7     = YUV: undefined bpp, undefined alignment
  * 9     = 2 bpp, aligned
- * 10    = undefined
+ * 10    = depth, aligned (8, 16, 24, 32, 32f)
  * 11    = undefined
  * 12    = 3 bpp, not aligned
  * 13    = 4 bpp, not aligned (e.g. 2101010)
@@ -305,7 +309,14 @@ typedef enum { /*< prefix=COGL_PIXEL_FORMAT >*/
   COGL_PIXEL_FORMAT_RGBA_1010102_PRE = (COGL_PIXEL_FORMAT_RGBA_1010102 | COGL_PREMULT_BIT),
   COGL_PIXEL_FORMAT_BGRA_1010102_PRE = (COGL_PIXEL_FORMAT_BGRA_1010102 | COGL_PREMULT_BIT),
   COGL_PIXEL_FORMAT_ARGB_2101010_PRE = (COGL_PIXEL_FORMAT_ARGB_2101010 | COGL_PREMULT_BIT),
-  COGL_PIXEL_FORMAT_ABGR_2101010_PRE = (COGL_PIXEL_FORMAT_ABGR_2101010 | COGL_PREMULT_BIT)
+  COGL_PIXEL_FORMAT_ABGR_2101010_PRE = (COGL_PIXEL_FORMAT_ABGR_2101010 | COGL_PREMULT_BIT),
+
+  COGL_PIXEL_FORMAT_DEPTH_ANY = (0 | COGL_DEPTH_BIT),
+  COGL_PIXEL_FORMAT_DEPTH_16  = (9 | COGL_DEPTH_BIT),
+  COGL_PIXEL_FORMAT_DEPTH_24  = (2 | COGL_DEPTH_BIT),
+  COGL_PIXEL_FORMAT_DEPTH_32  = (3 | COGL_DEPTH_BIT),
+
+  COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8 = (3 | COGL_DEPTH_BIT | COGL_STENCIL_BIT) 
 } CoglPixelFormat;
 
 /**
@@ -348,6 +359,8 @@ typedef enum { /*< prefix=COGL_PIXEL_FORMAT >*/
  *     supported with CoglBufferAccess including read support.
  * @COGL_FEATURE_MAP_BUFFER_FOR_WRITE: Whether cogl_buffer_map() is
  *     supported with CoglBufferAccess including write support.
+ * @COGL_FEATURE_DEPTH_TEXTURE: Whether #CoglFramebuffer support rendering the
+ *     depth buffer to a texture.
  *
  * Flags for the supported features.
  *
@@ -377,7 +390,8 @@ typedef enum
   COGL_FEATURE_SHADERS_ARBFP          = (1 << 20),
   COGL_FEATURE_MAP_BUFFER_FOR_READ    = (1 << 21),
   COGL_FEATURE_MAP_BUFFER_FOR_WRITE   = (1 << 22),
-  COGL_FEATURE_ONSCREEN_MULTIPLE      = (1 << 23)
+  COGL_FEATURE_ONSCREEN_MULTIPLE      = (1 << 23),
+  COGL_FEATURE_DEPTH_TEXTURE          = (1 << 24)
 } CoglFeatureFlags;
 
 /**
diff --git a/cogl/driver/gl/cogl-gl.c b/cogl/driver/gl/cogl-gl.c
index 3976d5a..ce0c9bc 100644
--- a/cogl/driver/gl/cogl-gl.c
+++ b/cogl/driver/gl/cogl-gl.c
@@ -199,6 +199,33 @@ _cogl_driver_pixel_format_to_gl (CoglContext *context,
       gltype = GL_UNSIGNED_SHORT_5_5_5_1;
       break;
 
+    case COGL_PIXEL_FORMAT_DEPTH_ANY:
+      glintformat = GL_DEPTH_COMPONENT;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_BYTE;
+      break;
+    case COGL_PIXEL_FORMAT_DEPTH_16:
+      glintformat = GL_DEPTH_COMPONENT16;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_SHORT;
+      break;
+    case COGL_PIXEL_FORMAT_DEPTH_24:
+      glintformat = GL_DEPTH_COMPONENT24;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_INT;
+      break;
+    case COGL_PIXEL_FORMAT_DEPTH_32:
+      glintformat = GL_DEPTH_COMPONENT32;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_INT;
+      break;
+
+    case COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8:
+      glintformat = GL_DEPTH24_STENCIL8;
+      glformat = GL_DEPTH_STENCIL;
+      gltype = GL_UNSIGNED_INT_24_8;
+      break;
+
     case COGL_PIXEL_FORMAT_ANY:
     case COGL_PIXEL_FORMAT_YUV:
       g_assert_not_reached ();
@@ -403,6 +430,13 @@ _cogl_driver_update_features (CoglContext *ctx,
                       COGL_FEATURE_ID_OFFSCREEN_MULTISAMPLE, TRUE);
     }
 
+  if (COGL_CHECK_GL_VERSION (gl_major, gl_minor, 3, 0) ||
+      _cogl_check_extension ("GL_ARB_depth_texture", gl_extensions))
+    {
+      flags |= COGL_FEATURE_DEPTH_TEXTURE;
+      COGL_FLAGS_SET (ctx->features, COGL_FEATURE_ID_DEPTH_TEXTURE, TRUE);
+    }
+
   if (COGL_CHECK_GL_VERSION (gl_major, gl_minor, 2, 1) ||
       _cogl_check_extension ("GL_EXT_pixel_buffer_object", gl_extensions))
     private_flags |= COGL_PRIVATE_FEATURE_PBOS;
diff --git a/cogl/driver/gles/cogl-gles.c b/cogl/driver/gles/cogl-gles.c
index 9e46d12..8f1e91d 100644
--- a/cogl/driver/gles/cogl-gles.c
+++ b/cogl/driver/gles/cogl-gles.c
@@ -33,6 +33,13 @@
 #include "cogl-renderer-private.h"
 #include "cogl-private.h"
 
+#ifndef GL_UNSIGNED_INT_24_8
+#define GL_UNSIGNED_INT_24_8 0x84FA
+#endif
+#ifndef GL_DEPTH_STENCIL
+#define GL_DEPTH_STENCIL 0x84F9
+#endif
+
 static CoglBool
 _cogl_driver_pixel_format_from_gl_internal (CoglContext *context,
                                             GLenum gl_int_format,
@@ -137,6 +144,35 @@ _cogl_driver_pixel_format_to_gl (CoglContext *context,
       gltype = GL_UNSIGNED_SHORT_5_5_5_1;
       break;
 
+    case COGL_PIXEL_FORMAT_DEPTH_ANY:
+      glintformat = GL_DEPTH_COMPONENT;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_BYTE;
+      break;
+    case COGL_PIXEL_FORMAT_DEPTH_16:
+      glintformat = GL_DEPTH_COMPONENT;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_SHORT;
+      break;
+    case COGL_PIXEL_FORMAT_DEPTH_24:
+      glintformat = GL_DEPTH_COMPONENT;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_INT;
+      break;
+    case COGL_PIXEL_FORMAT_DEPTH_32:
+      glintformat = GL_DEPTH_COMPONENT;
+      glformat = GL_DEPTH_COMPONENT;
+      gltype = GL_UNSIGNED_INT;
+      break;
+
+    case COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8:
+      /* GLES only supports GL_DEPTH_STENCIL (not GL_DEPTH24_STENCIL8)
+       * as the internal format */
+      glintformat = GL_DEPTH_STENCIL;
+      glformat = GL_DEPTH_STENCIL;
+      gltype = GL_UNSIGNED_INT_24_8;
+      break;
+
     case COGL_PIXEL_FORMAT_ANY:
     case COGL_PIXEL_FORMAT_YUV:
       g_assert_not_reached ();
@@ -247,6 +283,12 @@ _cogl_driver_update_features (CoglContext *context,
                       COGL_FEATURE_ID_UNSIGNED_INT_INDICES, TRUE);
     }
 
+  if (_cogl_check_extension ("GL_OES_depth_texture", gl_extensions))
+    {
+      flags |= COGL_FEATURE_DEPTH_TEXTURE;
+      COGL_FLAGS_SET (context->features, COGL_FEATURE_ID_DEPTH_TEXTURE, TRUE);
+    }
+
   if (_cogl_check_extension ("GL_OES_texture_npot", gl_extensions))
     {
       flags |= (COGL_FEATURE_TEXTURE_NPOT |
diff --git a/examples/cogl-info.c b/examples/cogl-info.c
index b7dab00..7c43fe2 100644
--- a/examples/cogl-info.c
+++ b/examples/cogl-info.c
@@ -109,6 +109,12 @@ struct {
     "GLES2 API integration supported",
     "Support for creating a GLES2 context for using the GLES2 API in a "
       "way that's integrated with Cogl."
+  },
+  {
+    COGL_FEATURE_ID_DEPTH_TEXTURE,
+    "Depth Textures",
+    "CoglFramebuffers can be configured to render their depth buffer into "
+    "a texture"
   }
 };
 
-- 
1.7.11.3.g3c3efa5

